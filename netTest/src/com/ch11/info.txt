RMI框架

创建一个简单地客户程序和服务器程序，客户端能调用服务器端的方法
在实际应用中，为了合理地分配软硬件资源，会把各种对象分布在不同的网络节点上，
这些对象之间能项目发送消息。


一个分布式对象模型中，一个对象不仅能被本地进程访问，还可以被远程进程访问，
就称为远程对象：如果一个对象只能被本地进程访问，就称为本地对象，为了保证各种对象之间可
靠地发送消息，该模型的实现系统通常使用TCP协议作为网络传输层的通信协议。

Tips
一个对象调用另一个对象的方法，按照面向对象的观点，可以理解为一个对象向另一个对象发送消息，如果两个
对象都运行在同一个进程中，则消息无须经过网络传输。如果两个对象分布在网络中不同的节点上，则消息需要经过
网络传输。


一般说来，远程对象都分布在服务器端，提供各种通用的服务。客户端则访问服务器端的远程对象，请求特定
的服务。如果实现这种分布式的对象模型呢？显然，不管采取何种方式，对象模型的实现系统都应该具备以下功能：
（1）把分布在不同节点上的对象之间发送的消息转换为字节序列，这一过程称为编组（marshalling）。
（2）通过套接字建立连接并且发送编组后的消息，即字节序列。
（3）处理网络连接或传输消息时出现的各种故障。
（4）为分布在不同节点上的对象提供分布式垃圾收集机制。
（5）为远程方法调用提供安全检查机制。
（6）服务器端运用多线程或非阻塞通信机制，确保远程对象具有很好的并发性能，能同时被多个客户访问。
（7）创建与特定问题领域相关的各种本地对象和远程对象。

由此可见，从头开发一个完善的分布式的软件系统很复杂，既要处理套接字连接、编组、分布式垃圾收集、安全检查和
并发性等问题，还要开发与实际问题领域相关的各种本地对象和远程对象。幸运的是，目前已经有一些现成的、成熟的分布式
对象模型的框架。

RMI（Remote Method Invoke）：JDK提供了一个完善的、简单易用的远程方法调用框架，它要求客户端与服务器端都是
java程序。

CORBA（Common Object Request Broker Architecture，通过对象请求代理体系结构）：分布式对象模型的通用框架，
允许用不同的语言编写的对象能彼此通信。

SOAP（simple object Access Protocol，简单对象访问协议）：允许异构的系统之间能彼此通信，以XML作为通信语言。一个
系统可以访问另一个系统对外公布的Web服务。

RMI框架封装了所有底层通信细节，并且解决了编组、分布式垃圾收集、安全检查和并发性等通用问题。有了现成的框架，开发人员就只需专注于
开发与特定问题领域相关的各种本地对象和远程对象了。

CORBA（Common Object Request Broker Architecture，通用对象请求代理体系结构）：分布式对象模型的通用框架，允许用不同
语言编写的对象能彼此通信。

SOAP（Simple Object Access Protocol，简单对象访问协议）：允许异构的系统之间能彼此通信，以XML作为通信语言。一个系统可以访问另
一个系统对外公布的Web服务，

RMI框架封装了所有底层通信细节，并且解决了编组、分布式垃圾收集、安全检查和并发性等通用问题。有了现成的框架，开发人员就只需专注于开发与特定问题领域相关的各种对象和远程对象了。



RMI的基本原理

RMI采用客户/服务器通信方式。在服务器上部署了提供各种服务的远程对象，客户端请求访问服务器上远程对象的方法。HelloServiceImple是一个远程对象，他运行在服务器上，客户端请求调用HelloServiceImpl对象的echo()方法。
RMI框架采用代理来负责客户与远程对象之间通过Socket进行通信的细节。RMI框架为远程对象分别生产成了客户端代理和服务器端代理。位于客户端的代理类称为存根（Stub），位于服务器端的代理类称为骨架（Skeleton）。

当客户端调用远程对象的一个方法时，实际上是调用本地存根对象的相应方法。存根对象与远程对象具有同样的接口。存根采用一种与平台无关的编码方式，把方法的参数编码为字节序列，这个编码过程称为参数编组。RMI主要采用Java序列化机制
进行参数编组。接着，存根把以下请求信息发送给服务器：

被访问的远程对象的名字。
被调用的方法的描述。
编组后的参数的字节序列。

服务器端接收到客户端的请求信息，然后由相应的骨架对象来处理这一请求信息，骨架对象执行以下操作：

反编组参数，即把参数的字节序列反编码的参数。
定位要访问的远程对象。
调用远程对象的相应方法。
获取方法调用产生的返回值或者异常，然后对它进行编组。
把编组后的参数值或者异常发送个客户。

Tips

存根类与远程对象所属的远程类实现了同样的远程接口，而骨架类并没有实现该远程接口，骨架类在服务器端为远程对象接收客户的方法调用请求，尽管骨架类的作用类似于代理类，
但严格地说，骨架类不算代理类，因为代理类必须与代理的类具有同样的接口。

 
客户端的存根接收到服务器发送过来的编组后的返回值或异常，再对它进行反编组，就得到调用远程方法的返回结果。

存根与骨架类通过Socket来通信。幸运的是，开发人员无需手工编写客户端的存根类及服务器端的骨架类，它们都由RMI框架创建。在JDK5.0以前的版本中，需要用rmic命令来远程
对象生成静态的代理类（包括存根和骨架类）。而在JDK5.0 中，RMI框架会在运行时自动为远程对象生成动态代理类（包括存根和骨架类），从而更彻底地封装了RMI框架的实现细节，简化了RMI
框架的使用方式。




------------

分布式垃圾收集

在java虚拟机中，对于一个本地对象，只要不被本地Java虚拟机内的任何变量引用，他就会结束生命周期，可以被垃圾回收器回收。而对于一个远程对象，不仅会被本地Java虚拟机内的变量引用，
还会被远程引用。服务器端的一个远程对象受到3中引用：
（1）服务器端的一个本地对象持有它的本地应用。
（2）这个远程对象已经注册到rmiregistry注册表，可以理解为，rmiregistry注册表持有它的远程引用。
（3）客户端获得了这个远程对象的存根对象，可以理解为，客户端持有它的远程引用。

RMI框架采用分布式垃圾收集机制（DGC，Distributed Garbage Collection）来管理远程对象的生命周期。DGC的主要规则是，只有当一个远程对象不受到任何本地引用和远程引用，这个远程
对象才会结束生命周期，并且可以被本地Java虚拟机的垃圾收集器回收。

服务器端如何知道客户端持有一个远程对象的远程引用呢？当客户端获得了一个服务器端的远程对象的存根时，就会向服务器发送一条租约通知，告诉服务器自己持有这个远程对象的引用了。客户端对这个远程
对象有一个租约期限。租约期限可通过系统属性java.rmi.dgc.leaseValue来设置，以毫秒为单位，它的默认值为60000毫秒 10分钟，当到达了租约期限的一半时间（默认是5分钟），客户端如果还持有远程引用，就会再次
向服务器发送租约通知。客户端不断的在给定的时间间隔中向服务器发送租约通知，从而使服务器知道客户端一直持有远程对象的引用。如果在租约到期后，服务器端没有继续收到客户端的新的租约通知，服务器端就会认为这个客户已经
不再持有远程对象的引用了。

租约期限即不能太长，也不能太短，应该根据实际情况来决定。如果租约期限太短，会导致客户端频繁想服务器无法快速检测客户端的异常终止。假定客户端发出一个租约
通知后，由于某种原因，突然终止运行。这时客户端不再也无法继续发送租约通知，而服务器端无法立即知道客户端已经结束运行，因为服务器端必须要等过了10个小时后，
由于没有收到客户端的新的租约通知，才能判断出客户端不再持有远程对象的引用了由此可见，如果租约期限太长，会使服务器长时间维持哪些实际上不再被任何客户引用的远程对象，
浪费服务器资源。

以上RMI框架管理远程对象的生命周期的过程应用程序时透明的。有时，远程对象希望在不再受到任何远程引用时执行一些操作，如释放占用的相关资源，以便安全的结束生命周期。这样的远程对象需要实现java.rmi.server.Unreferenced接口，
该接口中一个unreferenced()方法，远程对象可以在这个方法中执行释放占用的相关资源的操作。当RMI框架检测到一个远程对象不再受到任何远程引用时，就会调用这个对象的unreferenced()方法。







小结

RMI框架封装了用Socket通信的细节，使得应用程序可以像调用本地方法一样，去调用远程对象的方法。RMI框架的实现中运用了一下机制。
（1）分布式垃圾收集机制：对于一个远程对象，只有当它没有受到任何本地应用及远程引用时，才会结束生命周期。
（2）用远程接口来公布远程对象提供的服务。客户程序通过远程接口来调用远程对象的方法，这符合面向对象开发中的“公开接口，封装实现”的思想。
（3）客户端持有远程对象的引用，实际上是持有远程对象的存根对象的引用，存根对象充当远程对象的代理，两者具有同样的远程接口。
（4）运用动态加载机制，当客户端访问一个远程对象时，如果客户端不存在与远程对象相关的类，RMI框架会从java.rmi.server.codebase系统属性指定的位置加载它们。
（5）运用序列化机制对远程对象的方法的参数和返回值进行编组，把编组后的字节序列发送到接收方。
（6）把网络通信中产生的错误转换为一个RemoteException，使得应用程序可以按照处理Java异常的方式来处理底层的通信错误。

当应用程序通过ＲＭＩ框架进行远程方法调用时，在形式上与调用本地方法很相似，但还是存在以下区别：
（1）远程异常：所有的远程方法都会申明抛出RemoteException，客户端应该处理这种异常，以便在出现网络故障时，客户程序也能从容地处理异常并且恢复运行。

（2）用值传输：远程方法的参数和返回值只能是基本类型，或者是实现了Serializbale接口或Remote接口的引用类型。如果参数和返回值是可序列化的对象，那么就传送它们的序列化数据，
在接收方得到的是发送方对象的复制品。如果参数和返回值是远程对象，那么传送它们的存根对象，在接收方得到的是发送方的远程对象的存根对象。

（3）调用开销：远程方法调用比本地方法调用的开销更大，因为在进行远程方法调用时，参数和返回值都会经历编组、在网络上传输，及反编组的过程。为了减少调用开销，应该限制网络上传送的对象的大小。


（4）安全：远程方法调用比本地方法调用更加不安全。网络通信过程可能会被监听，或者传送的内容被恶意篡改。在客户端及服务器端应该使用安全管理器，设置与远程方法调用相关的安全策略。此外，如果不希望通信内容的传输途中被监听，可以在RMI
框架中设置基于SSL（安全套接字层）的套接字工厂：javax.rmi.SslRMIClientFactory和javax.rmi.SslRMIServerSocketFactory。





