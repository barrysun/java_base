ServerSocket用法详解

构造ServerSocket
ServerSocket的构造方法有以下几种重载形式：
ServerSocket() throws IOException
ServerSocket(int port)throws IOException
ServerSocket(int port,int backlog)throws IOException
ServerSocket(int port,int backlog,InetAddress bindAddr)throws IOException
在以上构造方法中，参数port指定服务器要绑定的端口（服务器要监听的端口），参数backlog
指定客户连接请求队列的长度，参数bindAddr指定服务器要绑定的IP地址。




设定客户请求队列的长度

当服务器进程运行时，可能会同时监听到多个客户的连接请求。例如，每当一个
客户进程执行以下代码：
Socket socket=new Socket("www.javathinker.org",80);
就意味着在远程 www.javathinker,org主机的80端口上，监听到了一个客户的连接
请求。管理客户连接请求的任务时由操作系统来完成的。操作系统把这些连接请求存储
在一个先进先出的队列中。许多操作系统限定了队列的最大长度，一般为50.当队列中的连接
请求达到了队列的最大容量时，服务器进程所在的主机会拒绝新的连接请求。
只有当服务器进程通过ServerSocket的accept()方法队列中取出连接请求，使队列
腾出空位时，队列才能继续加入新的连接请求。
对于客户进程，如果它发送的连接请求被加入到服务器的队列中，就意味着客户与服务器的连接建立成功
客户进程从构造方法中正常返回。如果客户进程发出的连接请求被服务器拒绝，
Socket构造方法就会抛出ConnectionException
ServerSocket构造方法的backlog参数用来显式设置连接请求队列的长度，它将覆盖操作
系统限定的队列的最大长度。值得注意的是，在以下几种情况中，仍然采用操作系统限定的队列的最大长度
backlog 参数的值大于操作系统限定的队列的最大长度
backlog 参数值小于或者等于0
在ServerSocket构造方法中没有设置backlog参数


获取ServerSocket的信息

ServerSocket的以下两个get方法可分别获得服务器绑定的IP地址，以及绑定的端口：



ServerSocket选项
ServerSocket有以下3个选项
SO_TIMEOUT:表示等待客户连接的超时时间
SO_REUSEADDR:表示是否允许重用服务器所绑定的地址
SO_RCVBUF:表示接收数据的缓冲区的大小






-----
创建多线程的服务器

EchoServer接收到一个客户连接，就与客户进行通信，通信完毕后断开连接，然后再接收下一个客户
连接。假如同时有多个客户请求连接，这些客户就必须排队等候EchoServer的响应。EchoServer无法
同时与多个客户通信。
许多实际应用要求服务器具有同时为多个客户提供服务的能力。HTTP服务器就
是最明显的例子。任何时刻，HTTP服务器都可能接收到大量的客户请求，每个客户都希望能快速得到HTTP
服务器的响应。如果长时间让客户等待，会使网站失去信誉，从而降低访问量。
可以用并发性能来衡量一个服务器同时响应多个客户的能力。一个具有好的并发性能的服务器，必须符合两个条件：
 能同时接收并处理多个客户连接
 对于每个客户，都会迅速给予响应。
服务器同时处理的客户连接数据越多，并且对每个客户做出响应的速度越快，就表明并发性能越高。
用多个线程来同时为多个客户提供服务，这是提高服务器的并发性能的最常用的手段。本节将按照3中方式来重新实现EchoServer，
他们都使用了多线程。
 为每个客户分配一个工作线程
 创建一个线程池，由其中的工作线程来为客户服务。
 利用JDK的java类库中现成的线程池，由它的工作线程来为客户服务。
 
 
 
 
 创建线程池
 
 对每个客户都分配一个新的工作线程。当工作线程与客户通信结束，这个线程就被销毁。这种实现方式有以下不同之处。
 （1）服务器创建和销毁工作线程的开销（包括所花费的时间和系统资源）很大。
 如果服务器需要与许多客户通信，并且与每个客户的通信时间都很短，那么
 有可能服务器与客户创建新线程的开销比实际与客户通信的开销还要大。
 （2）除了创建和销毁线程的开销之外，活动的线程也消耗系统资源。每个线程本身都会
 占用一定的内存（每个线程需要大概1MB内存），如果同时有大量客户
 连接服务器，就必须创建大量工作线程，它们消耗了大量内存，可能会导致系统的内存空间不足。
 （3）如果线程数目固定，并且每个线程都有很长的生命周期，那么线程切换也是
 相对固定的。不同操作系统有不同的切换周期，一般在20毫秒左右，这里所说的线程
 切换时指在Java虚拟机，以及底层操作系统的调度下，线程之间转让CPU的
 使用权，如果频繁创建和销毁线程，那么将导致频繁地切换线程，因为一个线程被销毁后，
 必然要把CPU转让给另一个已经就绪的线程，使该线程获得运行机会。在这种情况下，
 线程之间的切换不再遵循系统的固定切换周期，切换线程的开销甚至比创建及销毁线程的开销还大。
 线程池为线程生命周期开销问题和系统资源不足问题提供了解决方案。线程池中
 预先创建了一些工作线程，他们不断从工作队列中取出任务，然后执行该任务，当
 工作线程执行完一个任务时，就会继续执行工作队列中的下一个任务。线程池具有以下优点
 （3.1）减少了创建和销毁线程的次数，每个工作线程都可以一直被重用，能执行多个任务
 （3.2）可以根据系统的承载能力，方便地调整线程池中线程的数目，防止因为消耗过量系统资源而导致系统崩溃。
 
 
 
 
 
 使用线程池的注意事项
 
 虽然线程能大大提高服务器的并发性能，但使用它也会存在一定风险。与所有
 多线程应用程序一样，用线程池构建的应用程序容易产生各种并发问题，如对共享资源
 的竞争和死锁。此外，如果线程池本身的实现不健壮，或者没有合理地使用线程池，
 还容易导致与线程池有关的死锁、系统资源不足和线程泄露等问题。
 
 1 死锁
 
 任何多线程应用程序都有死锁风险。造成死锁的最简单地情形是，线程A持有对象X的锁，并且在
 等待对象Y的锁，而线程B持有对象Y的锁，并且等待对象X的锁。线程A与线程B都不释放自己持有的锁，
 并且等待对方的锁，这就导致两个线程永远等待下去，死锁就这样产生了。
 虽然任何多线程程序都有死锁的风险，但线程池还会导致另外一种死锁。在这种情形下，
 假定线程池中的所有工作线程都在执行各自任务时被阻塞，他们都在等待某个任务A的执行结果。而任务
 A依然在工作队列中，由于没有空闲线程，使得任务A一直不能被执行。这使得线程池中的所有工作线程
 都永远阻塞下去，死锁就这样产生了。
 
 2 系统资源不足
 
 如果线程池中的线程数目非常多，这些线程会消耗包括内存和其他系统资源在内的大量资源，从而
 严重影响系统性能。
 
 3 并发错误
 
 4 线程泄露
 
 5 任务过载
 
 





